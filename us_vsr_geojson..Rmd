---
title: "us_vsr_geojson"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## US VSR (vessel strike restrictions) zone data scraper

See [US VSR zone data scraper · Issue #2 · BenioffOceanInitiative/ws-sql](https://github.com/BenioffOceanInitiative/ws-sql/issues/2)

```{r}
library(XML)
library(RCurl)
library(geojsonsf)
library(geojsonio)
library(here)
library(sf)
library(tidyverse)
library(xml2)
# library(RJSONIO)

url  <- "https://apps-nefsc.fisheries.noaa.gov/cgi-bin/mammalmaps/xmlgenDMA.pl"
xml  <- RCurl::getURL(url)
data <- xmlTreeParse(xml, useInternalNodes = T)
d    <- read_xml(xml) # alternative method of reading in xml
# data_list <- xmlToList(xmlParse(xml), addAttributes = T, simplify = T)

# find all nodes, attributes, number of variables, etc. 
# still need to expand to include
# all attributes (probably with a function)
nodes <- xml_find_all(d, "//dma")
node_id <- xml_attr(nodes, "id")
node_name <- xml_attr(nodes, "name")
nodes_length <- xml_length(nodes)
node_names <- xml_name(xml_child(nodes))
node_values <- trimws(xml_children(nodes))
node_lat <- xml_attr(xml_find_all(nodes, "*[self::waypoint]"), "lat")
node_lon <- xml_attr(xml_find_all(nodes, "*[self::waypoint]"), "lon")

# create df
df <- tibble(
  id = rep(node_id, times = nodes_length),
  name = rep(node_name, times = nodes_length),
  variable = node_names,
  lat = node_lat, 
  lon = node_lon)
  
# df to sf
sf <- df %>% 
  st_as_sf(
    coords = c("lat", "lon"),
    crs = 4326)

# sf to geoJSON - not 100% sure if this is working
geo <- sf %>% 
  sf_geojson()

# add duplicate waypoint for each polygon

# still need to go back in and add all attributes
```


```{r}
# alternatively...
geo <- geojson_json(
  sf, geometry = "polygon", type = "FeatureCollection", crs = 4326)
```


```{r}
# json <- toJSON(d_list)
geo <- geojson_json(
  d_list, 
  # lat = "lat",
  # lon = "lon",
  group = "dma",
  geometry = "polygon",
  type = "GeometryCollection",
  crs = 4326)
  


# make df of attributes
d_list <- 


for (i in 1:length(d_list)) {
  d_list_attrs <- d_list_attrs %>% 
    
    bind_rows(d_list[i])}
    
    bind_rows(d_list[i]$dma$.attrs) %>% 





  
  
  values = node_values) %>% 
  separate(values, into = c("lat", "lon"), sep = " ", remove = T)
  mutate(values = gsub("[^0-9.-]", "", values)) %>% 
    st_as_sf()
  
  
  




df$values <- gsub("[^0-9.-]", ", ", df$values)


df$values <- str_replace(df$values, r"[a-zA-Z]")

  separate(values, into = c("lat", "lon"), sep = " ")







data_list <- rbind(data)



d <- xmlTreeParse(xml, useInternalNodes = T)

df_list <- lapply()





# with xml2 package
data <- xml2::read_xml(xml)
waypoints <- xml_find_all(data, "//waypoint")
dmas <- xml_find_all(data, "//dma") # this is good


wp_list <- waypoints %>% as_list # all the lat and lng info
dma_list <- dmas %>% as_list

id_1 <- dma_list[[1]]

dma_1 <- tibble()
for (i in 1:length(dma_list[[1]])) {
  dma_1 <- dma_1 %>% 
    bind_rows(dma_list[[1]][[i]])
}




for (i in 1:length(d_list)) {
  d_list_attrs <- d_list_attrs %>% 
    
    bind_rows(d_list[i])}
    
    bind_rows(d_list[i]$dma$.attrs) %>% 
    bind_rows(d_list[i]$dma$waypoint[[1]])
}



tibble <- doc %>% as_tibble %>% 
  unnest_wider("doc") %>% 
  unnest(cols = names(.)) %>% 
  unnest(cols = names(.)) %>% 
  type_convert()

doc_bound <- bind_cols(doc)












vals <- trimws(xml_find_all(dmas, "waypoint"))

# example
cols <- xml_attr(
  xml_find_all(
    pg, "//data/variables/*[self::categoricalvariable or
    self::realvariable]"),
  "name")
# pg = name of xmlstored in R
# //data/variables = next 2 levels of nodes
# self::categoricalvariable or self::realvariable = equal nesting, both under variables
# name = an attribute, same line as 'data'

# real
# grab id attribute from every dma
cols <- xml_attr(
  xml_find_all(
    d, "//areaNotices/*[self::dma]"),
  "id")

dat <- do.call(
  rbind,
  lapply(
    strsplit(vals, "\ "),
    function(x) {data.frame(rbind(setNames(as.numeric(x), cols)))
    }))


lat <- xml_attr(
  xml_find_all(
    d, "//areaNotices/dma/*[self::waypoint]"),
  "lat")









cols <- xml_attr(xml_find_all(d, "//areaNotices/dma/*[self::id or self::waypoint]"), "name")






# yet another method
doc <- xmlParse(xml)
top <- xmlRoot(doc)
df <- bind_cols(
  # ids for column 1
  X = unlist(doc["//dma/@id"], use.names = FALSE),
  read_table(
    # get all dmas as a character vector
    text = xmlValue(top[["areaNotices"]][["dma"]]),
    # get colnames from 'dma'
    col_names = xmlSApply(
      top[["areaNotices"]][["dma"]],
      xmlGetAttr,"name")
    # assign NA values to NA
  ))


xmldf <- xmlToDataFrame(nodes = getNodeSet(doc, "//dma"))
View(xmldf)










node2df <- function(node){
    # (Optinonally) read out properties of  some optional child node
    outputNodes = getNodeSet(node, "output")
    stdout = if (length(outputNodes) > 0) xmlValue(outputNodes[[1]]) else NA

    vec_as_df <- function(namedVec, row_name="name", value_name="value"){
        data_frame(name = names(namedVec), value = namedVec) %>% set_names(row_name, value_name)
    }

    # Extract all node properties
    node %>%
        xmlAttrs %>%
        vec_as_df %>%
        pivot_wider(names_from = name, values_from = value) %>%
        mutate(stdout = stdout)
}

testResults = xmlParse(xml) %>%
    getNodeSet("/testrun/suite/test", fun = node2df) %>%
    bind_rows()



# top <- xmlRoot(d)
# xmlName(top) # top root of tree
# names(top) # child nodes - 3 dma's
# names(top[[1]]) # waypoints for 1st dma
# names(top[[1]]) # might need to group all waypoints
# 

# xml_1 <- xmlto(top[[1]])
# 
# 
# 
# 
# waypoints <- top[[1]][[1:4]]
# (waypoints[[1]])
# waypoints
# 
# xmlSApply(top[[1]], xmlValue)



# data as list
d_list <- xmlToList(d, addAttributes = F, simplify = T) %>% 
  as_tibble() %>% 
  mutate(waypoint = c(1, 2, 3, 4))
  
  
  
  transpose() %>% 
  unnest(c(1:3))
  transpose(.names = )



# %>% 
#   bind_rows()

d_list_attrs <- tibble()

attrs <- d_list[1]$dma

for (i in 1:length(d_list)) {
  d_list_attrs <- d_list_attrs %>% 
    
    bind_rows(d_list[i])}
    
    bind_rows(d_list[i]$dma$.attrs) %>% 
    bind_rows(d_list[i]$dma$waypoint[[1]])
}






# d_list_attrs <- (d_list[1]$dma$.attrs) %>%
#   bind_rows()
#   as_tibble() %>% 
#   gather(key = "attribute", value = "value" )

d_list_attrs <- (d_list[1]$dma$.attrs) %>%
  bind_rows()



  as_tibble() %>% 
  gather(key = "attribute", value = "value" )




d_list_updated <- d_list %>% 
  as_tibble() %>% 
  pivot_longer(cols = everything(), names_to = "id", values_to = "attributes")
  unnest(cols = )


  

for (dma in d_list)



d_list_updated <- d_list %>% 
  




# now to convert from list to geojson










waypoints <- XML::xmlTreeParse(url, useInternal = TRUE)

ply_geojson <- here("data/nis.ccg-gcc.gc.ca_NAVWARNs.geojson")
ply <- geojson_sf(ply_geojson)
ply <- sf::read_sf(ply_geojson)
```


```{r}

```

Note that the `echo = FALSE` parameter was added to the code chunk to prevent printing of the R code that generated the plot.
